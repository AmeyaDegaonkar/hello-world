#!/usr/bin/env python3

from swift_msgs.msg import SwiftMsgs
from geometry_msgs.msg import PoseArray
from controller_msg.msg import PIDTune
from error_msg.msg import Error
import rclpy
from rclpy.node import Node

class Swift_Pico(Node):
    def __init__(self):
        super().__init__('pico_controller')

        # Drone state variables as lists [x,y,z]
        self.current_state = [0.0, 0.0, 0.0]
        self.desired_state = [-7, 0, 20]

        # Command message initialization
        self.cmd = SwiftMsgs()
        self.cmd.rc_roll = 1500
        self.cmd.rc_pitch = 1500
        self.cmd.rc_yaw = 1500
        self.cmd.rc_throttle = 1500
        self.cmd.rc_aux4 = 1000

        # PID parameters [roll, pitch, throttle]
        self.Kp = [0.0, 0.0, 0.0]
        self.Ki = [0.0, 0.0, 0.0]
        self.Kd = [0.0, 0.0, 0.0]

        # PID state tracking
        self.previous = [0.0, 0.0, 0.0]
        self.error_sum = [0.0, 0.0, 0.0]
        self.min_values = [1000, 1000, 1000]
        self.max_values = [2000, 2000, 2000]

        # Sample time for PID execution
        self.sample_time = 0.033

        # Publishers
        self.command_pub = self.create_publisher(SwiftMsgs, '/drone_command', 10)
        self.pos_error_pub = self.create_publisher(Error, '/pos_error', 10)

        # Subscriptions
        self.create_subscription(PoseArray, '/whycon/poses', self.whycon_callback, 1)
        self.create_subscription(PIDTune, "/throttle_pid", self.altitude_set_pid, 1)
        self.create_subscription(PIDTune, "/pitch_pid", self.pitch_set_pid, 1)
        self.create_subscription(PIDTune, "/roll_pid", self.roll_set_pid, 1)

        # Timer to repeatedly call pid()
        self.create_timer(self.sample_time, self.pid)

        # Arm the drone
        self.arm()

    def disarm(self):
        self.cmd.rc_roll = 1000
        self.cmd.rc_yaw = 1000
        self.cmd.rc_pitch = 1000
        self.cmd.rc_throttle = 1000
        self.cmd.rc_aux4 = 1000
        self.command_pub.publish(self.cmd)

    def arm(self):
        self.disarm()
        self.cmd.rc_roll = 1500
        self.cmd.rc_yaw = 1500
        self.cmd.rc_pitch = 1500
        self.cmd.rc_throttle = 1500
        self.cmd.rc_aux4 = 2000
        self.command_pub.publish(self.cmd)

    def whycon_callback(self, msg):
        if len(msg.poses) > 0:
            self.current_state[0] = msg.poses[0].position.x
            self.current_state[1] = msg.poses[0].position.y
            self.current_state[2] = msg.poses[0].position.z

    def altitude_set_pid(self, alt):
        self.Kp[2] = alt.kp * 0.03
        self.Ki[2] = alt.ki * 0.008
        self.Kd[2] = alt.kd * 0.6

    def pitch_set_pid(self, pitch):
        self.Kp[1] = pitch.kp * 0.06
        self.Ki[1] = pitch.ki * 0.004
        self.Kd[1] = pitch.kd * 0.3

    def roll_set_pid(self, roll):
        self.Kp[0] = roll.kp * 0.06
        self.Ki[0] = roll.ki * 0.004
        self.Kd[0] = roll.kd * 0.3

    def pid(self):
        # Calculate error per axis (desired - current)
        error = [0.0, 0.0, 0.0]
        for i in range(3):
            error[i] = self.desired_state[i] - self.current_state[i]
            self.error_sum[i] += error[i] * self.sample_time

        p = [self.Kp[i] * error[i] for i in range(3)]
        i_term = [self.Ki[i] * self.error_sum[i] for i in range(3)]
        d = [self.Kd[i] * (error[i] - self.previous[i]) / self.sample_time for i in range(3)]

        self.previous = error.copy()

        self.cmd.rc_roll = int(min(max(1500 + p[0] + i_term[0] + d[0], self.min_values[0]), self.max_values[0]))
        self.cmd.rc_pitch = int(min(max(1500 + p[1] + i_term[1] + d[1], self.min_values[1]), self.max_values[1]))
        self.cmd.rc_throttle = int(min(max(1500 + p[2] + i_term[2] + d[2], self.min_values[2]), self.max_values[2]))

        self.command_pub.publish(self.cmd)

        pos_error_msg = Error()
        pos_error_msg.roll_error = error[0]
        pos_error_msg.pitch_error = error[1]
        pos_error_msg.throttle_error = error[2]
        pos_error_msg.yaw_error = 0.0  # set as zero or use actual yaw error if calculated
        self.pos_error_pub.publish(pos_error_msg)

def main(args=None):
    rclpy.init(args=args)
    swift_pico = Swift_Pico()

    try:
        rclpy.spin(swift_pico)
    except KeyboardInterrupt:
        swift_pico.get_logger().info('KeyboardInterrupt, shutting down.\n')
    finally:
        swift_pico.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
